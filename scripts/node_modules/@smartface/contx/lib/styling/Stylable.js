(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports", "../core/Actor", "@smartface/styler/lib/utils/merge"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require("../core/Actor"), require("@smartface/styler/lib/utils/merge"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.Actor, global.merge);
    global.Stylable = mod.exports;
  }
})(this, function (module, exports, _Actor2, _merge) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = makeStylable;

  var _Actor3 = _interopRequireDefault(_Actor2);

  var _merge2 = _interopRequireDefault(_merge);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // TODO create new jsdoc type for the parameter
  /**
   * Styleable Actor HOC. Decorates specifeid component and return an actor component
   * 
   * @param {object} component - A component to decorate
   * @param {string} className - initial className for actor
   * @param {function} hooks - context's hooks dispatcher
   * 
   * @returns {Object} - A Stylable Actor
   */
  function makeStylable(_ref) {
    var component = _ref.component,
        _ref$classNames = _ref.classNames,
        classNames = _ref$classNames === undefined ? "" : _ref$classNames,
        _ref$initialProps = _ref.initialProps,
        initialProps = _ref$initialProps === undefined ? {} : _ref$initialProps,
        name = _ref.name;

    var initialClassNames = classNames && classNames.split(" ") || [];
    initialProps = (0, _merge2.default)(initialProps);

    /**
     * Styable actor
     * @class
     */
    return new (function (_Actor) {
      _inherits(Stylable, _Actor);

      function Stylable() {
        _classCallCheck(this, Stylable);

        var _this = _possibleConstructorReturn(this, _Actor.call(this, component));

        _this.getName = function () {
          return name;
        };

        _this.setStyles = function (style) {
          var reduceDiffStyleHook = _this.hook("reduceDiffStyleHook");

          var diffReducer = reduceDiffStyleHook ? reduceDiffStyleHook(_this.styles || {}, style) : function (acc, key) {
            if (_this.styles[key] !== undefined) {
              if (_this.styles[key] !== style[key]) {
                acc[key] = style[key];
              } else {
                acc[key] = style[key];
              }
            }

            return acc;
          };

          var diff = Object.keys(style).reduce(diffReducer, {});

          _this.styles === initialProps && (diff = (0, _merge2.default)(diff, initialProps));

          var beforeHook = _this.hook("beforeStyleDiffAssign");
          beforeHook && (diff = beforeHook(diff));

          var comp = name.indexOf("_") === -1 && _this._actorInternal_.component.layout ? _this._actorInternal_.component.layout : _this._actorInternal_.component;
          var hasDiff = Object.keys(diff).length > 0;

          typeof component.subscribeContext === "function" ? hasDiff && component.subscribeContext({ type: "new-styles", data: Object.assign({}, diff) }) : hasDiff && Object.keys(diff).forEach(function (key) {
            try {
              /*if (key == "scrollEnabled") {
                comp.ios && (comp.ios.scrollEnabled = diff[key]);
              } else */
              if (key === "layoutHeight") {
                // component.layout.height
                comp.layout['height'] = diff[key];
              } else if (key === "layoutWidth") {
                // component.layout.width
                comp.layout['width'] = diff[key];
              } else if (key !== "font" && style[key] instanceof Object) {
                Object.keys(diff[key]).forEach(function (k) {
                  comp[key][k] = diff[key][k];
                });
              } else {
                comp[key] = diff[key];
              }
            } catch (e) {
              throw new Error(key + " has invalid value " + JSON.stringify(style[key]) + " " + e.message);
            }
          });

          var afterHook = _this.hook("afterStyleDiffAssign");
          afterHook && (style = afterHook(style));

          _this.styles = style;
        };

        _this.getStyles = function () {
          return _this.styles ? Object.assign({}, _this.styles) : {};
        };

        _this.getClassName = function () {
          return _this.classNames.join(" ");
        };

        _this.classNamesCount = function () {
          return _this.classNames.length;
        };

        _this.removeClassName = function (className) {
          if (_this.hasClassName(className)) {
            _this.isDirty = true;
            _this.classNames = _this.classNames.filter(function (cname) {
              return cname !== className;
            });
          }

          return _this.getClassName();
        };

        _this.resetClassNames = function () {
          var classNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          _this.classNames = [].concat(initialClassNames, classNames);
          _this.isDirty = true;
        };

        _this.hasClassName = function (className) {
          return _this.classNames.some(function (cname) {
            return cname === className;
          });
        };

        _this.pushClassNames = function (classNames) {
          if (!_this.hasClassName(classNames)) {
            Array.isArray(classNames) ? _this.classNames = [].concat(_this.classNames, classNames) : _this.classNames.push(classNames);

            _this.isDirty = true;
          }

          return _this.getClassName();
        };

        _this.addClassName = function (className, index) {
          if (!_this.hasClassName(className)) {
            _this.classNames.splice(index, 1, className);
            _this.isDirty = true;
          }

          return _this.getClassName();
        };

        _this.dispose = function () {
          component.setContextDispatcher && component.setContextDispatcher(null);
          _this._actorInternal_.component = null;
          _this._actorInternal_ = null;
          _this.context = null;
          _this.styles = null;
          component.onDispose && component.onDispose();
          component = null;
        };

        _this.classNames = [].concat(initialClassNames);
        _this.styles = initialProps;
        _this.isDirty = true;
        return _this;
      }

      /**
       * Sets styles
       *
       * @param {object} styles - a style object
       */


      Stylable.prototype.getInitialClassName = function getInitialClassName() {
        return initialClassNames;
      };

      return Stylable;
    }(_Actor3.default))();
  }
  module.exports = exports["default"];
});