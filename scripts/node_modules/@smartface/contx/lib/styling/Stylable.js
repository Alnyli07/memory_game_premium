(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["module", "exports", "../core/Actor", "@smartface/styler/lib/utils/merge"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module, exports, require("../core/Actor"), require("@smartface/styler/lib/utils/merge"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod, mod.exports, global.Actor, global.merge);
    global.Stylable = mod.exports;
  }
})(this, function (module, exports, _Actor2, _merge) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = makeStylable;

  var _Actor3 = _interopRequireDefault(_Actor2);

  var _merge2 = _interopRequireDefault(_merge);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // {"backgroundColor":{"nativeObject":{}},"paddingLeft":10,"paddingRight":10,"paddingTop":null,"paddingBottom":10,"flexDirection":0,"alignItems":2,"direction":0,"flexWrap":0,"justifyContent":4}

  // function addChild(componentAddChild, child, actor) {
  //   componentAddChild(child);
  //   actor.dispatch({ type: "invalidateContext" });
  // }

  // function addChild(componentAddChild, child, actor) {
  //   componentAddChild(child);
  // }

  // TODO create new jsdoc type for the parameter
  /**
   * Styleable Actor HOC. Decorates specifeid component and return an actor component
   * 
   * @param {object} component - A component to decorate
   * @param {string} className - initial className for actor
   * @param {function} hooks - context's hooks dispatcher
   * 
   * @returns {Object} - A Stylable Actor
   */
  function makeStylable(_ref) {
    var component = _ref.component,
        _ref$classNames = _ref.classNames,
        classNames = _ref$classNames === undefined ? "" : _ref$classNames,
        _ref$initialProps = _ref.initialProps,
        initialProps = _ref$initialProps === undefined ? {} : _ref$initialProps,
        name = _ref.name;

    var initialClassNames = classNames && classNames.split(" ") || [];
    initialProps = (0, _merge2.default)(initialProps);

    /**
     * Styable actor
     * @class
     */
    return new (function (_Actor) {
      _inherits(Stylable, _Actor);

      function Stylable() {
        _classCallCheck(this, Stylable);

        var _this = _possibleConstructorReturn(this, _Actor.call(this, component));

        _this.getName = function () {
          return name;
        };

        _this.setStyles = function (style) {

          var reduceDiffStyleHook = _this.hook("reduceDiffStyleHook");

          var diffReducer = reduceDiffStyleHook ? reduceDiffStyleHook(_this.styles || {}, style) : function (acc, key) {
            if (_this.styles[key] !== undefined) {
              if (_this.styles[key] !== style[key]) {
                acc[key] = style[key];
              } else {
                acc[key] = style[key];
              }
            }

            return acc;
          };

          var diff = Object.keys(style).reduce(diffReducer, {});

          _this.styles === initialProps && (diff = (0, _merge2.default)(diff, initialProps));

          var beforeHook = _this.hook("beforeStyleDiffAssign");
          beforeHook && (diff = beforeHook(diff));

          var comp = name.indexOf("_") === -1 && _this._actorInternal_.component.layout ? _this._actorInternal_.component.layout : _this._actorInternal_.component;
          var hasDiff = Object.keys(diff).length > 0;

          typeof component.subscribeContext === "function" ? hasDiff && component.subscribeContext({ type: "new-styles", data: Object.assign({}, diff) }) : hasDiff && Object.keys(diff).forEach(function (key) {
            try {
              /*if (key == "scrollEnabled") {
                comp.ios && (comp.ios.scrollEnabled = diff[key]);
              } else if(key === "layoutHeight") { // component.layout.height
                comp.layout['height'] = diff[key];
              } else if(key === "layoutWidth") { // component.layout.width
                comp.layout['width'] = diff[key];
              } else */
              if (key !== "font" && style[key] instanceof Object) {
                Object.keys(diff[key]).forEach(function (k) {
                  comp[key][k] = diff[key][k];
                });
              } else {
                comp[key] = diff[key];
              }
            } catch (e) {
              throw new Error(key + " has invalid value " + JSON.stringify(style[key]) + " " + e.message);
            }
          });

          var afterHook = _this.hook("afterStyleDiffAssign");
          afterHook && (style = afterHook(style));

          _this.styles = style;
        };

        // this.name = name;
        _this.classNames = [].concat(initialClassNames);
        // componentVars.classNames && 
        //   (this.classNames = this.classNames.concat(componentVars.classNames.split(" ")));
        // className && this.classNames.push(className);
        // initialClassNames = [...this.classNames];
        _this.styles = initialProps;
        _this.isDirty = true;

        // if (typeof component.addChild === "function")
        // component.addContextChild = addChild.bind(component, this);
        // else if(name.indexOf("statusBar") == -1 && typeof component.layout.addChild === "function")
        //   component.layout.addContextChild = addChild.bind(component, component.layout.addChild.bind(component.layout), this);
        return _this;
      }

      /**
       * Sets styles
       *
       * @param {object} styles - a style object
       */


      Stylable.prototype.getStyles = function getStyles() {
        return this.styles ? Object.assign({}, this.styles) : {};
      };

      Stylable.prototype.getInitialClassName = function getInitialClassName() {
        return initialClassNames;
      };

      Stylable.prototype.getClassName = function getClassName() {
        return this.classNames.join(" ");
      };

      Stylable.prototype.classNamesCount = function classNamesCount() {
        return this.classNames.length;
      };

      Stylable.prototype.removeClassName = function removeClassName(className) {
        if (this.hasClassName(className)) {
          this.isDirty = true;
          this.classNames = this.classNames.filter(function (cname) {
            return cname !== className;
          });
        }

        return this.getClassName();
      };

      Stylable.prototype.resetClassNames = function resetClassNames() {
        var classNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        this.classNames = [].concat(initialClassNames, classNames);
        this.isDirty = true;
      };

      Stylable.prototype.hasClassName = function hasClassName(className) {
        return this.classNames.some(function (cname) {
          return cname === className;
        });
      };

      Stylable.prototype.pushClassNames = function pushClassNames(classNames) {
        if (!this.hasClassName(classNames)) {
          Array.isArray(classNames) ? this.classNames = [].concat(this.classNames, classNames) : this.classNames.push(classNames);

          this.isDirty = true;
        }

        return this.getClassName();
      };

      Stylable.prototype.addClassName = function addClassName(className, index) {
        if (!this.hasClassName(className)) {
          this.classNames.splice(index, 1, className);
          this.isDirty = true;
        }

        return this.getClassName();
      };

      Stylable.prototype.dispose = function dispose() {
        component = null;
        this._actorInternal_ = null;
        this.context = null;
        this.styles = null;
        this.component.setContextDispatcher && this.component.setContextDispatcher(null);
      };

      return Stylable;
    }(_Actor3.default))();
  }
  module.exports = exports["default"];
});